<h1>Fewer Page Components</h1>

<p>Reducing the number of page components is the performance golden rule, the
single most important thing when it comes to building faster pages. If you have
time for only one performance optimization, focus on this one.

<p>Having fewer page components sounds like common sense - when you have fewer
images, scripts and styles, the page becomes lighter and therefore it should
load faster. However having fewer components doesn't necessarily mean stripping
features from the page. In this chapter (and the book) the assumption is that
you have a page that needs to be optimized to load faster while keeping the
exact same look and the exact same features.

<p>In an effort to provide a deeper understanding of the art and science of
performance optimization, this chapter goes into some technical details such as
how HTTP and TCP/IP work. If these topics are new to you and you feel a little
overwhelmed, don't be alarmed; just give them some time to sink in.

<h2>Waterfalls</h2>

<p>In order to optimize page loading times you need to have an idea of what's
going on with that page - how exactly does the page get loaded in the browser
and what could potentially be slowing it down. If you don't know that you'll be
shooting in the dark and there's always the risk of wasting time and effort
optimizing the parts that are already relatively fine.

<p>It's also helpful to know how the page loading process works in general -
from typing a URL into the browser to rendering a completely loaded page.

<p>To help you visualize what's going on behind the scenes as the page loads,
there are the so-called <em>waterfall views</em> provided by a number of
developer tools. To mention just two examples:

<ul>
  <li>In Firefox you can inspect the waterfall in Firebug's Net panel (<b>Figure
  3.1.</b>) <li>For an insight into Internet Explorer, you can use the online
  tool WebPageTest.org (<b>Figure 3.2.</b>) and look at the waterfalls without
  installing any new software
</ul>


<p>
  <img src="../images/03.01.net panel.png"> <div class="caption"><em>Figure
  3.1.</em> Waterfall view in Firebug's Net panel</div>
</p>

<p>
  <img src="../images/03.02.waterfall.png"> <div class="caption"><em>Figure
  3.2.</em> Waterfall view of twitter.com in WebPageTest</div>
</p>

<p><b>Figure 3.2.</b> shows the waterfall chart produced by WebPageTest when
loading twitter.com in IE7. You see that the HTML page is downloaded first,
followed by the other individual components (scripts, styles, images) linked to
from the page or from the other components (e.g. background images linked from
CSS). You may notice that the components are not downloaded all at the same
time. In fact this figure is a partial screenshot; the list of components
continues until all of them are downloaded. The view of the components getting
downloaded forms a picture that indeed looks like a waterfall.

<p>You can see on this screenshot that twitter.com's HTML page is loaded in
under a second while the page plus all the components take over four seconds. In
this case, as with most sites out there, the venerable 80/20 rule applies. The
page itself takes only about 20% of the total time while most of the time is
spent fetching components. So when you plan an optimization, it makes sense to
focus on where you can achieve the best results. Saving half of 80% will be a
significant and noticeable gain, while cutting 20% down in half - not so much.

<h2>The HTTP Request</h2>

<p>You can see in the waterfall chart that each component has a bar with
different color-coded information. Each of these bars represents an <em>HTTP
request</em> and the colors in the bars represent a specific activity. The
length of a bar or a piece of it corresponds to the time taken by each of the
activities. Let's examine these colors closer, taking the first bar - Twitter's
HTML page - as an example (<b>Figure 3.3.</b>).

<p>
  <img src="../images/03.03.http-request.png"> <div class="caption"><em>Figure
  3.3.</em> An HTTP request</div>
</p>

<ul>
  <li><p>Dark green represents the time taken to perform a <em>DNS lookup</em>.
  DNS (Domain Name Service) lookup is the process of matching the friendly
  domain name twitter.com to an IP address (such as 128.242.240.20), which the
  browser needs in order to know how to get in touch with the server. Think of
  the DNS lookup as being like a phone book: your browser knows the name
  (twitter.com) but needs the number (the IP address).</p>
      <p>You can see on the waterfall chart on <b>Figure 3.2.</b> that a
      separate DNS lookup needs to be done for every domain (twitter.com,
      a1.twimg.com, a3.twimg.com, s.twimg.com) because sub-domains may live on a
      different server with a different IP address.</p></li>
  <li>Orange is the time to establish a <em>connection</em> between the server
  and the browser. We'll talk about this some more in just a bit.</li> <li>Light
  green is the <em>time-to-first byte</em> (TTFB) when the browser waits for the
  very first piece of information to be sent by the server. In the case of
  dynamic HTML pages this is the time spent to assemble the whole page on the
  server. If you're busy optimizing databases and server-side code, you'll
  actually be optimizing the TTFB of the page. As you can see, in the grand
  scheme of things, this is not where you should be focusing because it has
  relatively low impact (unless, of course, there's something seriously wrong on
  the server-side)</li> <li>Blue is the time spent actually <em>downloading</em>
  the component</li>
</ul>

<p>[[ Is it possible use the same colors from the graphic to highlight the
italics part of the text? For example use dark green to style DNS lookup in the
first number point]]

<p>If you look at the overall waterfall picture you'll notice that there's not a
lot of blue bars. This means that significant time is being spent not
downloading files.

<h2>The Myth About Broadband</h2>

<p>You may often hear lines such as "everybody has broadband these days" or "our
target audience is 30-something professionals and they all have fast
connections." These are excuses not to invest in speeding up a site and are, in
fact, a disservice to the user. There are several things wrong with such
"broadband" statements.

<p>First of all, there are many users with slow connections - both in and
outside the US. Some users are still on modem connections but many more are
surfing the web using smart phones, which are particularly prone to having
problematic connections. Other users are sharing a WiFi connection either at a
caf&eacute; or at home. It doesn't take much to slow down a shared WiFi
connection - having someone next to you on a video chat or even having your
microwave oven on are just two examples of things that can interfere with your
downloads.

<p>Additionally, a little-known fact is that the <em>upstream</em> bandwidth is
usually just 20% of the total bandwidth advertised by the Internet Service
Provider (ISP) and this matters not only for big file uploads but for requesting
regular page components too.

<p>And finally, as you can see in the waterfall diagrams, a significant amount
of time is spent in activities other than downloading files. Broadband can only
help when it comes to the blue bars.

<h3>The tubes</h3>

<p>You've probably heard the humorous term "intertubes" used to describe the
Internet infrastructure as series of tubes. This is incorrect, but it can still
be used as a way to visualize bandwidth. If you think of the dial-up modem
connection as a regular pipe, then the broadband connection will be a <em>fat
pipe</em> with a bigger diameter.

<p>What travels inside those pipes are packets. Every file is sent in a series
of small packets. The packets travel pretty fast, in the best case at around 2/3
of the speed of light and that is great, there isn't much room for improvement
there. A fat broadband pipe means that more and bigger packets can travel in
parallel, while a narrow pipe can handle fewer and smaller packets, mainly in
sequence one after the other, which slows down the transfers.

<p>The problem is that the fat tube is often not utilized to its potential. You
can either accept that as a fact and skip the next section of the chapter, or
brace yourself for some low-level details.

<h3>File Transfers</h3>

<p>In order to initiate a file transfer, the browser and the server need to
establish a connection between the two of them. The time it takes to establish a
connection is represented by the orange parts of the bars in the waterfall
graph.

<div class="sidebar"><h4>TCP/IP</h4>
  <p>Internet Protocol (IP) handles the delivery of messages (also know as
  packets) from one computer to another over a network. Transmission Control
  Protocol (TCP) abstracts the details of IP and makes sure these packets are
  properly constructed on one end and also make sense on the other end. TCP uses
  some metadata headers to describe what travels in each packet. SYN and ACK are
  types of metadata that comes with the packets. SYN (sequence number) is used
  to identify packets so they can be reassembled, because the network is a
  strange place with traffic jams and sometimes packets may arrive out of order,
  if at all. ACK means "Acknowledged" and is a way for one of the computes to
  say "OK, got that" to the other.</p></div>

<p>A new connection (<b>Figure 3.4.</b>) is established by performing a
<em>three-way handshake</em>:

<p>
  <img src="../images/03.04.three-way handshake.png"> <div
  class="caption"><em>Figure 3.4.</em> The three-way handshake</div>
</p>

<ul>
  <li>The browser sends a SYN, which is a new sequence ID</li> <li>The server
  acknowledges with an ACK and also sends a SYN</li> <li>The browser
  acknowledges with ACK and at this point the two have been properly introduced
  and are ready to start talking</li>
</ul>

<p>These handshake packets are small and regardless of the available bandwidth,
they travel at the same speed. A user may have a fast connection, but at this
stage it will not be used.

<p>Once a connection is established, then the actual transfer of a file (say, an
image) can start. The file is usually sent in several packets, depending on its
size. The server sends one packet and waits for acknowledgement ACK from the
browser. The ACK may additionally say something like "hey, I can handle bigger
packets", so the server sends a bigger packet. This repeats several times until
the connection is "saturated" with the right size packets. This process is known
as <em>TCP slow start</em> and is another reason why broadband is less important
than we might think. A fast connection definitely helps for downloading bigger
files, but for a series of small files spread across different domains (each
requiring a DNS lookup, a connection and a slow start), it's not all that
helpful.

<p>When it comes to network transfers, you can say it's a jungle out there. The
browser and client don't actually talk directly to each other; there are ISPs
and all kinds of proxies between them. Many bad things may happen in the network
jungle that prevent proper fast downloads. Sometimes a packet is lost, or it's
dropped somewhere along the way. In this case the server has to resend it, if
the server doesn't receive an [ACK] after a timeout. Sometimes the client is
overwhelmed by too many packets (imagine a mobile device with limited memory)
and cannot ACK anymore. That's also the reason for the existence of the TCP slow
start process - the server cannot know in advance what type of client is on the
other end and therefore takes baby steps in order to determine that.

<p>There's a tool called NetMon, which gives an overwhelming amount of details
of the network activity on Windows at the packet level. Another tool from
Microsoft works on top of NetMon and is called VRTA (Visual RoundTrip Analyzer);
it gives a much friendlier view of the data. You can see an example request on
<b>Figure 3.5.</b> which shows visually the TCP slow start effect. The little
blue bars represent the gradual opening of the TCP window size. You can also see
a pink line, which shows when the connection is established and a grey line,
which shows the TTFB. <b>Figure 3.6.</b> shows what you see when you mouse over
a request in VRTA; you can probably recognize the first three lines in the list
of packets showing the three-way handshake.

<p>
  <img src="../images/03.05.VRTA request.png"> <div class="caption"><em>Figure
  3.5.</em> A request in VRTA visualizing the TCP slow start</div>
</p>

<p>
  <img src="../images/03.06.VRTA packets.png"> <div class="caption"><em>Figure
  3.6.</em> List of packets in VRTA</div>
</p>

<p>One last nail in the broadband myth's coffin - most browsers only establish
two connections per domain name. This means that only two files can be
downloaded at the same time, which results in underutilizing the fat pipe. This
behavior is in the HTTP standard, so we cannot blame browsers for following the
standard. The problem is that the standard was created a long time ago. Luckily,
there's light at the end of the tunnel - new browsers (Firefox 3+, Safari 4+,
Chrome, Opera 10+, IE8+) offer 6 to 8 connections. But legacy browsers with
large market share such as IE6 and IE7 only use 2 parallel connections.

<h3>Take Home</h3>

<p>Let's summarize why having many HTTP requests (many page components) is bad
and why broadband is not the answer to all performance problems:

<ul>
  <li>Every HTTP request comes with overhead</li> <li>The time spent downloading
  a file is just a fraction of the total time needed to transfer the file</li>
  <li>Broadband helps download time, especially for large files</li>
  <li>Broadband doesn't help much in the other activities - DNS lookup,
  establishing a connection, TTFB</li> <li>The fat pipe of the broadband
  connection is often not used to its potential</li> <li>Browsers limit the
  number of connections per host</li> <li>Lots of users (think mobile) don't
  have broadband connections </li>
</ul>

<h2>The Myth About Cache</h2>

<p>You may think that this whole TCP stuff is all fascinating (albeit a bit
dry), but you wonder whether it really matters? When it comes to page components
such as images and stylesheets, aren't they all in the cache after the first
page view?

<p>The truth is that "it's all in the cache" is another common myth. For various
reasons a surprising amount of visitors will always come to your site with an
empty cache.

<p>An experiment done with the Yahoo! front-page revealed that:

<ul>
  <li>40-60% of the daily visitors come with empty cache</li> <li>20% of all the
  <em>page view</em>s are always empty cache views</li>
</ul>

<p>Since yahoo.com is a very popular destination and a home page for many users,
one would assume that the users almost always will be coming with a full cache.
Turns out that that's not the case. About half the users will visit the site
today and come back tomorrow with an empty cache.

<p>Why so many empty cache experiences? It's due to various reasons: people
clear their caches, sometimes automatically on browser shutdown, or sometimes
anti-virus programs do it too. Or the cache fills up and is partially flushed
between visits. Most browsers have about 50Mb maximum cache space, which is not
all that much when you think about it, given today's rich web sites and people's
browsing habits (we do much more online these days than just a few years ago).

<p>So it's important to keep that in mind and keep optimizing for the empty
cache experience. Towards the end of the chapter you'll see some more details on
how to help caching.

<h2>Script and Style Bundles</h2>

<p>By now you should realize that the more HTTP requests your page requires, the
more overhead you'll have and therefore the slower the page will be. Reducing
the number of HTTP request is the best thing you can to speed up a page.

<p>Let's take a look at how you go about reducing the components in practice. Of
course, the easiest way is to simply remove features from the page. But we want
to keep the same design while making the page faster. So the reduction of page
components will mean merging existing components together into bundles.

<p>Often developers have several JavaScripts and stylesheets on the same page.
This is convenient during development but when it comes to publishing the live
site, you should combine all JavaScript files into one file and all CSS into one
stylesheet.

<p>Let's say you're working on a page that uses jQuery and two plugins for it.
There's also has some custom non-library code, written specifically for the
page. This page is likely to have a piece of code that looks like so:

<div class="hl-main"><pre><span class="hl-brackets">&lt;</span><span class="hl-reserved">script</span><span class="hl-code"> </span><span class="hl-var">src</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">js/jquery.js</span><span class="hl-quotes">&quot;</span><span class="hl-code"> </span><span class="hl-var">type</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">text/javascript</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">&gt;</span><span class="hl-brackets">&lt;/</span><span class="hl-reserved">script</span><span class="hl-brackets">&gt;</span><span class="hl-code">
</span><span class="hl-brackets">&lt;</span><span class="hl-reserved">script</span><span class="hl-code"> </span><span class="hl-var">src</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">js/jquery.form.js</span><span class="hl-quotes">&quot;</span><span class="hl-code"> </span><span class="hl-var">type</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">text/javascript</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">&gt;</span><span class="hl-brackets">&lt;/</span><span class="hl-reserved">script</span><span class="hl-brackets">&gt;</span><span class="hl-code">
</span><span class="hl-brackets">&lt;</span><span class="hl-reserved">script</span><span class="hl-code"> </span><span class="hl-var">src</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">js/jquery.lightbox.js</span><span class="hl-quotes">&quot;</span><span class="hl-code"> </span><span class="hl-var">type</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">text/javascript</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">&gt;</span><span class="hl-brackets">&lt;/</span><span class="hl-reserved">script</span><span class="hl-brackets">&gt;</span><span class="hl-code">
</span><span class="hl-brackets">&lt;</span><span class="hl-reserved">script</span><span class="hl-code"> </span><span class="hl-var">src</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">js/myapplication.js</span><span class="hl-quotes">&quot;</span><span class="hl-code"> </span><span class="hl-var">type</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">text/javascript</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">&gt;</span><span class="hl-brackets">&lt;/</span><span class="hl-reserved">script</span><span class="hl-brackets">&gt;</span></pre></div>

<p>When you create a new file <code>all.js</code>  and paste into it the
contents of all other files, you end up with just one script tag:

<div class="hl-main"><pre><span class="hl-brackets">&lt;</span><span class="hl-reserved">script</span><span class="hl-code"> </span><span class="hl-var">src</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">js/all.js</span><span class="hl-quotes">&quot;</span><span class="hl-code"> </span><span class="hl-var">type</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">text/javascript</span><span class="hl-quotes">&quot;</span><span class="hl-brackets">&gt;</span><span class="hl-brackets">&lt;/</span><span class="hl-reserved">script</span><span class="hl-brackets">&gt;</span></pre></div>

<p>And just like that you save three additional HTTP requests and make the page
load faster. Chapter 6 has more details on optimizing JavaScript and will
demonstrate that script files suffer from an additional browser behavior - they
are all downloaded in sequence, slowing down the waterfall. Therefore it's
especially important to make sure that the page requires as few script files as
possible.

<p>After bundling all scripts, then you repeat the same process and bundle all
the stylesheets. You'll end up with a single CSS file:

<div class="hl-main"><pre><span class="hl-brackets">&lt;</span><span class="hl-reserved">link</span><span class="hl-code"> </span><span class="hl-var">href</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">all.css</span><span class="hl-quotes">&quot;</span><span class="hl-code"> </span><span class="hl-var">type</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">text/css</span><span class="hl-quotes">&quot;</span><span class="hl-code"> </span><span class="hl-var">rel</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">stylesheet</span><span class="hl-quotes">&quot;</span><span class="hl-code"> </span><span class="hl-brackets">/&gt;</span></pre></div>

<p>Pages often have separate print media stylesheets. These are not an exception
and should also go into the bundle, wrapped in a <code>@media print {...}
</code>declaration. Chapter 8 provides more details on how to optimize CSS for
faster rendering and will demonstrate that, curiously enough, the page will not
render on the <em>screen</em>, until the <em>print</em> stylesheets arrive.

<p>An additional positive side effect of combining several files into one is
that the result bundle often has smaller file size than the sum of the separate
parts. This is due to the compression, a topic discussed in the next chapter.

<h3>Drawbacks and solutions</h3>

<p>Many performance optimizations have their drawbacks. Most often the main
drawback is <em>inconvenience</em>. Imagine the end of a long working day, you
can barely finish fixing a layout bug in IE6 and now you have to also combine
the file you were working on together with all other files, create a bundle and
"push" it live. Creating a bundle is an extra step but it can be made less of a
chore with a simple script that does it for you and even copies it to the live
site. Another option is to have a server-side script (usually called a
<em>combo</em> script) that combines the files on demand. A combo script also
makes sense when you have too many little pieces, which are dynamically combined
depending on some factors. For example, the Yahoo! User Interface (YUI) library
uses a combo script to combine dynamically only the pieces of the library that
you may need. The result is URLs that look like the following:

<p><code>http://yui.yahooapis.com/combo?3.0.0/build/yui/yui-min.js&amp;3.0.0/build/oop/oop-min.js&amp;3.0.0/build/event-custom/event-custom-min.js</code>

<div class="sidebar"><h4>Expires</h4>
  <p>It's important to remember to properly set the Expires HTTP header in the
  combo script in order to promote better caching. Otherwise scripts are usually
  never cached. More details on Expires header to follow, but here's an example
  of how you could set proper expiration if your combo script was written in
  PHP:
    <div class="hl-main"><pre><span class="hl-var">$expiration</span><span class="hl-code"> = </span><span class="hl-identifier">mktime</span><span class="hl-brackets">(</span><span class="hl-brackets">)</span><span class="hl-code"> + </span><span class="hl-number">60</span><span class="hl-code"> * </span><span class="hl-number">60</span><span class="hl-code"> * </span><span class="hl-number">24</span><span class="hl-code"> * </span><span class="hl-number">365</span><span class="hl-code"> * </span><span class="hl-number">10</span><span class="hl-code">; </span><span class="hl-comment">//</span><span class="hl-comment"> now plus 10 years</span><span class="hl-comment"></span><span class="hl-code"></span>
<span class="hl-identifier">header</span><span class="hl-brackets">(</span><span class="hl-quotes">'</span><span class="hl-string">Expires: </span><span class="hl-quotes">'</span><span class="hl-code"> . </span><span class="hl-identifier">gmdate</span><span class="hl-brackets">(</span><span class="hl-quotes">'</span><span class="hl-string">D, d M Y h:m:s</span><span class="hl-quotes">'</span><span class="hl-code">, </span><span class="hl-var">$expiration</span><span class="hl-brackets">)</span><span class="hl-code"> . </span><span class="hl-quotes">'</span><span class="hl-string"> GMT</span><span class="hl-quotes">'</span><span class="hl-brackets">)</span><span class="hl-code">;</span></pre></div>
  
</p></div>

<p>Another drawback of bundling is that the resulting bundle becomes a
monolithic piece of code. This can harm cacheability because even the tiniest
change in one of the pieces will result in a new bundle, which the users will
have to download because they don't have it cached. But on the other hand you
saw that the cache is not as important as most people think and optimizing for
the empty cache experience is critical. A solution to that may be to have two
bundles: one that contains library-type of code, which rarely changes and an
additional one that is likely to change often.

<p>Despite the inconveniences of the bundles, they are highly recommended way to
speed up a page and their benefits greatly outweigh the drawbacks.

<h2>Combining Images</h2>

<p>Now that you know how combining scripts and styles into bundles helps improve
performance, let's see what we can do about reducing the number of image
components. When talking about images in web pages, we can divide them into two
categories:

<ul>
  <li><strong>Background images</strong> that you link to from your stylesheets
  using properties such as <code>background-image</code> and
  <code>list-style-image</code>. These are <em>decoration images</em> that make
  the pages look and feel nicer, but are not essential to the way the page
  works. With CSS disabled, the page should do its function even without the
  decoration images.</li> <li><strong>Content images</strong> that you include
  using <code>&lt;img /&gt;</code> tags. We can call them content images because
  they contribute to the purpose of the page (e.g. a photo in a news article).
  They should be visible even if the browser has no CSS support or CSS is turned
  off.</li>
</ul>

<p>We'll take a look at two ways to reduce images - combining them into CSS
sprites and using data URIs. Both of the techniques can address any type of
image, but the sprites are mostly suitable for background images while the data
URIs are used for both images types.

<h3>CSS Sprites</h3>

<p>CSS sprites are a way to reduce the number of images by combining several
images into one. You do that by simply creating one big image and pasting each
of the little ones next to each other. Then you use the background-position CSS
property to display only the part of the image you need. This is an excellent
technique to improve page download speed because you can easily put tens of
little icons into one image and download them all at once saving a lot of the
HTTP request overhead. Sprites have a side benefit in that they effectively
preload images for you. When you have a new image showing up on mouse over, it's
actually the same image and it's already downloaded, you only change the
background-position property of the page element.

<p>Let's see an example of a real-life sprite, used on Yahoo!'s search page. In
<b>Figure 3.7.</b> you see the <em>sprite image</em>, which contains a number of
smaller icons and other imagery that we'll call <em>sprite elements</em>. At the
bottom of the image you can see a little globe icon and on <b>Figure 3.8.</b>
you can see how this icon is used on the search results page next to the "Show
All" label.

<p>
  <img src="../images/03.07.yahoo sprite.png"> <div class="caption"><em>Figure
  3.7.</em> The sprite on Yahoo!'s search results page</div>
</p>

<p>
  <img src="../images/03.08.sprite in action.png"> <div
  class="caption"><em>Figure 3.8.</em> The globe sprite element used in the
  page</div>
</p>

<p>Using the X and Y coordinate system that starts from the top left corner of
the sprite image, the position of the globe element is x=101 and y = 108
(<b>Figure 3.9.</b>). In order to show that globe icon on the page you need to
do the following in your CSS code:

<p>
  <img src="../images/03.09.sprite coordinates.png"> <div
  class="caption"><em>Figure 3.9.</em> Coordinates of the globe element within
  the sprite</div>
</p>

<ul>
  <li>Set the <code>background-image</code> to point to the image URL e.g.
  <code>sprite.png</code></li> <li>Set the <code>background-position</code> to
  the coordinates of the sprite element with a minus sign, in this case
  <code>-101px -108px</code></li> <li>To prevent other parts of the sprite
  bleeding into your page element you can fix its width and height creating a
  box with dimensions foe example 16px by 16px</li>
</ul>

<p>At the end you'll end up with CSS code that looks like the following:

<div class="hl-main"><pre><span class="hl-identifier">.all-sites-icon</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span class="hl-reserved">background-image:</span><span class="hl-code"> </span><span class="hl-code">url</span><span class="hl-code">(</span><span class="hl-code">sprite</span><span class="hl-code">.</span><span class="hl-code">png</span><span class="hl-code">)</span><span class="hl-reserved"></span><span class="hl-code">;
  </span><span class="hl-reserved">background-position:</span><span class="hl-code"> -</span><span class="hl-number">101</span><span class="hl-string">px</span><span class="hl-code"> -</span><span class="hl-number">108</span><span class="hl-string">px</span><span class="hl-reserved"></span><span class="hl-code">;
  </span><span class="hl-reserved">width:</span><span class="hl-code"> </span><span class="hl-number">16</span><span class="hl-string">px</span><span class="hl-reserved"></span><span class="hl-code">;
  </span><span class="hl-reserved">height:</span><span class="hl-code"> </span><span class="hl-number">16</span><span class="hl-string">px</span><span class="hl-reserved"></span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<h3>Sprite Tools</h3>

<p>Creating and maintaining sprites involves calculating and keeping track of
all the different dimensions and positions and it could be a pain. Luckily there
are several tools that can help along the way. One such tool is the free online
service at <a href="http://csssprites.com">csssprites.com</a> (<b>Figure
3.10.</b>). It allows you to upload as many separate images as you need and
generates:

<p>
  <img src="../images/03.10.csssprites.com.png"> <div class="caption"><em>Figure
  3.10.</em> CSSSprites.com</div>
</p>

<ul>
  <li>The image sprite</li> <li>The CSS code needed to show each of the elements
  of the sprite</li> <li>An example that uses the result sprite and the
  generated CSS code, so you can see how it will look like in a real working
  page</li>
</ul>

<h3>Data URIs</h3>

<p>A technique called <em>data URIs</em> lets you embed the contents of an image
into an HTML page or a CSS stylesheet.

<p>In this technique instead of setting the URL (or URI) of an image in a page,
you use the actual <em>contents</em> of the image file (in other words its
<em>data</em>) as a URI.

<p>Usually you have an image tag like:

<div class="hl-main"><pre><span class="hl-brackets">&lt;</span><span class="hl-reserved">img</span><span class="hl-code"> </span><span class="hl-var">src</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">http://example.org/myimage.png</span><span class="hl-quotes">&quot;</span><span class="hl-code"> </span><span class="hl-brackets">/&gt;</span></pre></div>

<p>An image that uses a data URI will look like:

<div class="hl-main"><pre><span class="hl-brackets">&lt;</span><span class="hl-reserved">img</span><span class="hl-code"> </span><span class="hl-var">src</span><span class="hl-code">=</span><span class="hl-quotes">&quot;</span><span class="hl-string">data:image/png;base64,iVBOR...rkJggg==</span><span class="hl-quotes">&quot;</span><span class="hl-code"> </span><span class="hl-brackets">/&gt;</span></pre></div>

<p>The syntax may be a little scary, but it boils down to:

<ul>
  <li><code>data:</code> - the protocol instead of <code>http:</code></li>
  <li><code>image/png</code> - the content type of the image</li>
  <li><code>base64</code>  - the type of encoding that is used to encode the
  image data</li> <li>the rest after the comma is the contents of the file</li>
</ul>

<p>It's necessary to encode the image contents using the base64 encoding because
otherwise the images are binary files and may have all kinds of weird characters
in them, characters that are not welcome in an HTML page because they might
break it. Although you can specify the type of encoding, the base64 is actually
the only type of encoding currently supported by the browsers. Base64 represents
any type of data using just a subset of known characters (64 of them).

<p>Most server-side programming languages have built-in functions to do base64
encoding and decoding. For example in PHP you have the functions
<code>base64_encode()</code> and <code>base64_decode()</code>. Consider this
line:

<div class="hl-main"><pre><span class="hl-inlinetags">&lt;?php</span><span class="hl-code"> </span><span class="hl-reserved">echo</span><span class="hl-code"> </span><span class="hl-identifier">base64_encode</span><span class="hl-brackets">(</span><span class="hl-quotes">'</span><span class="hl-string">speed matters</span><span class="hl-quotes">'</span><span class="hl-brackets">)</span><span class="hl-code">; </span><span class="hl-inlinetags">?&gt;</span></pre></div>

<p>This will print <code>c3BlZWQgbWF0dGVycw==</code> and this is the
base64-encoded version of the words "speed matters".

<p>If you have PHP installed you can simply encode files on the command line,
like so:

<div class="hl-main"><pre><span class="hl-code">$ </span><span class="hl-identifier">php</span><span class="hl-code"> -</span><span class="hl-identifier">r</span><span class="hl-code"> </span><span class="hl-quotes">&quot;</span><span class="hl-string">echo base64_encode(file_get_contents('myimage.png'));</span><span class="hl-quotes">&quot;</span></pre></div>

<p>If you're not comfortable with the command line or a server-side programming
language, you can always use one of the several available online tools that
offer base64 encoding.

<p>In addition to using data URIs in <code>&lt;img /&gt;</code> tags for content
images, you can use them in CSS stylesheets as well, especially if these are
dynamic styles or the images should not be in a sprite for one reason or
another.

<p>The syntax to embed the image data into a CSS file will be:

<div class="hl-main"><pre><span class="hl-identifier">.myclass</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span class="hl-reserved">background-image:</span><span class="hl-code"> </span><span class="hl-code">url</span><span class="hl-code">(&quot;</span><span class="hl-code">data</span><span class="hl-code">:</span><span class="hl-code">image</span><span class="hl-code">/</span><span class="hl-code">png</span><span class="hl-reserved"></span><span class="hl-code">;</span><span class="hl-identifier">base64</span><span class="hl-code">,</span><span class="hl-identifier">iVBOR</span><span class="hl-code">..</span><span class="hl-identifier">.rkJggg</span><span class="hl-code">==&quot;);
</span><span class="hl-brackets">}</span></pre></div>

<h3>Data URIs in the Wild</h3>

<p>If you're curious whether these data URIs have practical use, let's see a few
examples "in the wild". Google search and Yahoo! search are two sites that
really care about performance and they both use data URIs.

<p>Google search results use data URIs for images like video and image
thumbnails (<b>Figure 3.11.</b>) as a way to reduce the number of requests. The
drawback is that these embedded images will not be cached by the browser and
will make the page heavier. But in the case of search results it's not all that
likely that the user will see the same thumbnail again next month. That's
because they won't be searching for the same thing and also the images and
videos will change for newer ones.

<p>
  <img src="../images/03.11.google data uris.png"> <div
  class="caption"><em>Figure 3.11.</em> Data URIs on Google's search
  results</div>
</p>

<p>Yahoo! search uses data URIs in CSS for images such as gradients that repeat
horizontally (<b>Figure 3.12.</b>). If these images were in a sprite, they would
need to span the whole width of the sprite image, which could be an inefficient
use of the image space. Instead, a slice of the gradient image with 1px width is
embedded in the CSS file.

<p>
  <img src="../images/03.12.yahoo data uris.png"> <div
  class="caption"><em>Figure 3.12.</em> Data URIs in a stylesheet</div>
</p>

<h3>MHTML</h3>

<p>Now if you thought the syntax of the data URIs was complex, wait until you
see this MHTML stuff. MHTML comes into the picture because of everybody's
"favorite" browser - Internet Explorer 6 and its following release IE7. (You
didn't think you could read a book about web design without mentioning IE6
exceptions, right?) While data URIs work fine in all modern browsers including
IE8, they are not supported by IE6 and IE7. You have two options to work around
this limitation:

<ul>
  <li>use data URIs for modern browsers and plain old URLs for IE6 and 7. The
  users of IE will not get the optimization and same fast experience, but at
  least the rest of the users will.</li> <li>use data URIs for all and MHTML
  only for IE before version 8.</li>
</ul>

<p>MHTML stands for MIME HTML. It's a way to have several files (parts) in the
same document. MIME (Multipurpose Internet Mail Extensions) is used in email
systems where several part of a message (text, HTML, attachments) are sent in a
single email message.

<p>Let's see an example of how to embed files in CSS stylesheets using MHTML.

<p>First, take a look at a single "part" representing a single image:

<div class="hl-main"><pre><span class="hl-identifier">Content</span><span class="hl-code">-</span><span class="hl-identifier">Location</span><span class="hl-code">: </span><span class="hl-identifier">myimage</span><span class="hl-code">
</span><span class="hl-identifier">Content</span><span class="hl-code">-</span><span class="hl-identifier">Transfer</span><span class="hl-code">-</span><span class="hl-identifier">Encoding</span><span class="hl-code">: </span><span class="hl-identifier">base64</span><span class="hl-code">

</span><span class="hl-identifier">iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAD</span><span class="hl-code">....</span><span class="hl-identifier">U5ErkJggg</span><span class="hl-code">==</span></pre></div>


<p>As you can probably guess the long line is an image encoded using base64
encoding. The first two lines are headers describing the data that comes after
that: <code>myimage</code> is a unique identifier and <code>base64</code>
specifies the type of encoding.

<p>Now in order to have several of these parts, you need a way to separate them.
You do that by using a string you select as a separator, such as  "MYSEPARATOR".
You also need a header for the whole document, which declares the separator
string. Overall the document will look like:

<div class="hl-main"><pre><span class="hl-code">Content-Type: </span><span class="hl-identifier">multipart</span><span class="hl-code">/</span><span class="hl-identifier">related</span><span class="hl-code">; </span><span class="hl-identifier">boundary</span><span class="hl-code">=&quot;</span><span class="hl-identifier">MYSEPARATOR</span><span class="hl-code">&quot;
 
--</span><span class="hl-identifier">MYSEPARATOR</span><span class="hl-code">
</span><span class="hl-brackets">[</span><span class="hl-var">here</span><span class="hl-code"> </span><span class="hl-var">comes</span><span class="hl-code"> </span><span class="hl-var">part</span><span class="hl-code"> </span><span class="hl-var">one</span><span class="hl-brackets">]</span><span class="hl-code">
--</span><span class="hl-identifier">MYSEPARATOR</span><span class="hl-code">
</span><span class="hl-brackets">[</span><span class="hl-var">here</span><span class="hl-code"> </span><span class="hl-var">is</span><span class="hl-code"> </span><span class="hl-var">part</span><span class="hl-code"> </span><span class="hl-var">two</span><span class="hl-code">, </span><span class="hl-var">followed</span><span class="hl-code"> </span><span class="hl-var">by</span><span class="hl-code"> </span><span class="hl-var">a</span><span class="hl-code"> </span><span class="hl-var">final</span><span class="hl-code"> </span><span class="hl-var">separator</span><span class="hl-brackets">]</span><span class="hl-code">
--</span><span class="hl-identifier">MYSEPARATOR--</span></pre></div>

<p>Note the double dashes, they are critical in order to make it all work.

<p>You'll need to wrap this whole document in a comment and put it in the top of
your CSS file. Then in the actual CSS <code>background-image</code> declarations
you refer to each part using its identifier, like so:

<div class="hl-main"><pre><span class="hl-identifier">.myclass</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span class="hl-reserved">background-image:</span><span class="hl-code"> </span><span class="hl-code">url</span><span class="hl-code">(</span><span class="hl-code">mhtml</span><span class="hl-code">:</span><span class="hl-code">http</span><span class="hl-code">://</span><span class="hl-code">example</span><span class="hl-code">.</span><span class="hl-code">org</span><span class="hl-code">/</span><span class="hl-code">styles</span><span class="hl-code">.</span><span class="hl-code">css</span><span class="hl-code">!</span><span class="hl-code">myimage</span><span class="hl-code">)</span><span class="hl-reserved"></span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<p>The URLs for the MHTML parts use the <code>mhtml:</code> protocol, then the
absolute URL of the stylesheet and finally an exclamation followed by an
identifier.

<p>A complete working example of a CSS will look like the following:

<div class="hl-main"><pre><span class="hl-comment">/*</span><span class="hl-comment">
Content-Type: multipart/related; boundary=&quot;MYSEPARATOR&quot;

--MYSEPARATOR
Content-Location: myimage
Content-Transfer-Encoding: base64

iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAD....U5ErkJggg==
--MYSEPARATOR
Content-Location: another
Content-Transfer-Encoding: base64

iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAA....U5ErkJggg==
--MYSEPARATOR--
</span><span class="hl-comment">*/</span><span class="hl-code">
</span><span class="hl-identifier">.myclass</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span class="hl-reserved">background-image:</span><span class="hl-code"> </span><span class="hl-code">url</span><span class="hl-code">(</span><span class="hl-code">mhtml</span><span class="hl-code">:</span><span class="hl-code">http</span><span class="hl-code">://</span><span class="hl-code">example</span><span class="hl-code">.</span><span class="hl-code">org</span><span class="hl-code">/</span><span class="hl-code">styles</span><span class="hl-code">.</span><span class="hl-code">css</span><span class="hl-code">!</span><span class="hl-code">myimage</span><span class="hl-code">)</span><span class="hl-reserved"></span><span class="hl-code">;
</span><span class="hl-brackets">}</span><span class="hl-code">

</span><span class="hl-identifier">.myotherclass</span><span class="hl-code"> </span><span class="hl-brackets">{</span><span class="hl-code">
  </span><span class="hl-reserved">background-image:</span><span class="hl-code"> </span><span class="hl-code">url</span><span class="hl-code">(</span><span class="hl-code">mhtml</span><span class="hl-code">:</span><span class="hl-code">http</span><span class="hl-code">://</span><span class="hl-code">example</span><span class="hl-code">.</span><span class="hl-code">org</span><span class="hl-code">/</span><span class="hl-code">styles</span><span class="hl-code">.</span><span class="hl-code">css</span><span class="hl-code">!</span><span class="hl-code">another</span><span class="hl-code">)</span><span class="hl-reserved"></span><span class="hl-code">;
</span><span class="hl-brackets">}</span></pre></div>

<h3>MHTML Drawbacks</h3>

<p>Needless to say, MHTML has some drawbacks:

<ul>
  <li>It is pretty complex. Still you'll probably have a server-side script
  generate MHTML for you and once you get it right, you don't need to think
  about it much, so that's not such a big issue.</li> <li>All this work will be
  only to support legacy IE versions.</li> <li>If you use the same stylesheet
  for all browsers, it will double the size of the image content because you
  need to have the image once as a data URI and once using MHTML. Another option
  is to serve browser-specific stylesheet files.</li>
</ul>

<p>These are serious drawbacks that make MHTML inapplicable for most sites. But
if you need ultra high-speed experience across all browsers, MHTML is a working
option for IE before 8.

<h2>"Never Expire" Policy</h2>

<p>If 50% of your visitors have an empty cache that means that the other 50% do
have some of the page components stored on their system. Let's not forget about
them. You can speed up their experience if the browser doesn't have to download
anything other than the dynamic HTML page and any new content images. To help
you achieve better repeat visits experience, let's consider the "never expire"
policy.

<p>But before digging into this, let's quickly look into what an HTTP request
looks like in terms of syntax and its body and header parts.

<h3>HTTP Headers</h3>

<p>The browser and the server talk to each other using the HTTP protocol. The
browser makes a request and the browser returns a response. Each request and
response has headers and optionally a body. The body is the actual data being
exchanged and the headers contain some information about that data.

<div class="sidebar"><h4>HTTP/TCP/IP - all together</h4>

<p>We talked about packets and how they have headers of metadata and bodies of
content. Now we talk about HTTP headers. Let's take a moment to see how it all
fits together.

<p>When a server needs to send a file, e.g. an image, to the browser, it finds
the image on the disc, adds some meta information in the form of headers and
creates an HTTP response that needs to reach the browser. This HTTP response is
given to the TCP subsystem, which is also part of the server software. The TCP
is responsible for splitting this HTTP response into packets and using the IP
(Internet Protocol) to send these little packets and make sure they are received
by the browser.</div>

<p>Think of the HTTP response as a letter you get in the mail. The actual
content of the letter is the body of the response. The envelope information
contains headers, instructing you and the mailman what to do with the letter. If
you're a secret agent you might get instructions to burn the letter after
reading. If it's a boring tax document, you might get instructions to retain it
in your records for at least seven years. In HTTP these instructions will come
in the header of a request.

<p>It's easy to see what the headers look like. In Firefox you just open
Firebug's Net panel and expand a request line (<b>Figure 3.13.</b>). In the Net
panel the headers are slightly formatted for prettier printing, but you can see
the raw contents using the "View Source" option in Net panel (not the "View
Source" of the browser which only shows you the body of a response)

<p>
  <img src="../images/03.13.http headers net panel.png"> <div
  class="caption"><em>Figure 3.13.</em> HTTP headers view in Firebug's Net
  panel</div>
</p>

<p>A simple HTTP request looks like the following:

<div class="hl-main"><pre><span class="hl-identifier">GET</span><span class="hl-code"> / </span><span class="hl-identifier">HTTP</span><span class="hl-code">/1.1
Host: </span><span class="hl-identifier">search</span><span class="hl-identifier">.yahoo</span><span class="hl-identifier">.com</span><span class="hl-code">
User-Agent: </span><span class="hl-identifier">Mozilla</span><span class="hl-code">/5.0 ...</span></pre></div>


<p>The first line of the request says "get me the page at /" (where / means the
root of the domain). Then a number of key-value pairs follow, one pair on each
line and the keys separated from the values by a colon.

<p>Similarly the HTTP <em>response</em> contains one line with the status of the
response (e.g. 200 OK or 404 Not Found), followed by a number of key-value pairs
representing the HTTP headers. At the end of the headers there's an empty line
and the body of the response (e.g. an HTML page) starts.

<div class="hl-main"><pre><span class="hl-identifier">HTTP</span><span class="hl-code">/</span><span class="hl-number">1.1</span><span class="hl-code"> </span><span class="hl-number">200</span><span class="hl-code"> </span><span class="hl-identifier">OK</span><span class="hl-code">
</span><span class="hl-identifier">Transfer</span><span class="hl-code">-</span><span class="hl-identifier">Encoding</span><span class="hl-code">: </span><span class="hl-identifier">chunked</span><span class="hl-code">
</span><span class="hl-identifier">Content</span><span class="hl-code">-</span><span class="hl-identifier">Type</span><span class="hl-code">: </span><span class="hl-identifier">text</span><span class="hl-code">/</span><span class="hl-identifier">html</span><span class="hl-code">; </span><span class="hl-identifier">charset</span><span class="hl-code">=</span><span class="hl-identifier">UTF</span><span class="hl-code">-</span><span class="hl-number">8</span><span class="hl-code">
</span><span class="hl-identifier">Content</span><span class="hl-code">-</span><span class="hl-identifier">Encoding</span><span class="hl-code">: </span><span class="hl-identifier">gzip</span>

<span class="hl-brackets">&lt;</span><span class="hl-code">!</span><span class="hl-var">doctype</span><span class="hl-code"> </span><span class="hl-var">html</span><span class="hl-brackets">&gt;</span><span class="hl-code">
</span><span class="hl-brackets">&lt;</span><span class="hl-reserved">html</span><span class="hl-brackets">&gt;</span><span class="hl-code">
  </span><span class="hl-brackets">&lt;</span><span class="hl-reserved">head</span><span class="hl-brackets">&gt;</span><span class="hl-brackets">&lt;</span><span class="hl-reserved">title</span><span class="hl-brackets">&gt;</span><span class="hl-code">...</span></pre></div>

<p>All these headers have their special meanings and some of them are important
to performance optimization. We'll discuss the important ones throughout the
book, starting right now with the Expires header.

<h3>Expires Headers</h3>

<p>The Expires header is one of the important HTTP headers when it comes to
performance. It instructs the browsers how long a page or a page component could
be stored in the cache (e.g. "burn after reading" or "keep for 7 years").

<div class="hl-main"><pre><span class="hl-identifier">Expires</span><span class="hl-code">: </span><span class="hl-identifier">Mon</span><span class="hl-code">, </span><span class="hl-number">09</span><span class="hl-code"> </span><span class="hl-identifier">Sep</span><span class="hl-code"> </span><span class="hl-number">2019</span><span class="hl-code"> </span><span class="hl-number">07</span><span class="hl-code">:</span><span class="hl-number">04</span><span class="hl-code">:</span><span class="hl-number">49</span><span class="hl-code"> </span><span class="hl-identifier">GMT</span></pre></div>

<p>This example header says that this component could be kept in cache until
2019. Another header is called Cache-Control: and it can give the expiration
time not as an exact date but as number of seconds. Both of these headers help
caching and anything you can do to help caching is a good thing.

<p>If the <code>Expires</code> header is missing, the browser has to guess how
long the component is good for and could request it (often conditionally) if it
suspects that the component has expired and probably has a newer version.

<p>The "never expire" policy is to always set an expiration date for static
components (scripts, styles, images) and make that date way in the future, for
example ten years in the future. This is simple to do and is just a
configuration of you web server. Assuming your server is Apache (the most
popular) and you're editing the special file called <code>.htaccess</code>
(which most hosting providers allow you to edit), you can write:

<div class="hl-main"><pre><span class="hl-identifier">ExpiresActive</span><span class="hl-code"> </span><span class="hl-reserved">On</span><span class="hl-code">
</span><span class="hl-identifier">ExpiresByType</span><span class="hl-code"> </span><span class="hl-identifier">application</span><span class="hl-code">/</span><span class="hl-identifier">x</span><span class="hl-code">-</span><span class="hl-identifier">javascript</span><span class="hl-code"> </span><span class="hl-quotes">&quot;</span><span class="hl-string">access plus 10 years</span><span class="hl-quotes">&quot;</span><span class="hl-code">
</span><span class="hl-identifier">ExpiresByType</span><span class="hl-code"> </span><span class="hl-identifier">text</span><span class="hl-code">/</span><span class="hl-identifier">css</span><span class="hl-code"> </span><span class="hl-quotes">&quot;</span><span class="hl-string">access plus 10 years</span><span class="hl-quotes">&quot;</span><span class="hl-code">
</span><span class="hl-identifier">ExpiresByType</span><span class="hl-code"> </span><span class="hl-identifier">image</span><span class="hl-code">/</span><span class="hl-identifier">png</span><span class="hl-code"> </span><span class="hl-quotes">&quot;</span><span class="hl-string">access plus 10 years</span><span class="hl-quotes">&quot;</span></pre></div>


<p>Now if you access a PNG image on May 3rd, 2010, Apache will add this header
to the HTTP response:

<div class="hl-main"><pre><span class="hl-identifier">Expires</span><span
class="hl-code">: </span><span class="hl-identifier">Sun</span><span
class="hl-code">, </span><span class="hl-number">03</span> <span class="hl-identifier">May</span><span class="hl-code"> </span><span
class="hl-number">2020</span><span class="hl-code"> </span><span
class="hl-number">09</span><span class="hl-code">:</span><span
class="hl-number">09</span><span class="hl-code">:</span><span
class="hl-number">47</span><span class="hl-code"> </span><span
class="hl-identifier">GMT</span></pre></div>

<p>The browser should never request this file again till 2020, effectively
caching it "forever".

<p>The drawback is that you cannot modify this file anymore, since some users
have already cached it until 2020. If you need to change the file, you have to
save it under a different name and update all references to it. For the new name
you can use consecutive numbers, or a timestamp, or even the so-called
<em>hashes</em> of the content, so that the name reflects the actual body of the
component.

<p class="sidebar">Note that setting the Expires header is no guarantee that the
component will remain in the cache, it's just a suggestion. You don't tell
browsers what to do, you just ask them, very politely.</p>







